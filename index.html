<script>
let HIST_DATA = [];
let CORR_MATRIX = {};
let trendChartInstance = null;

const RULES = [
    { 
        name: "保守型策略", type: "hot", pool: "last1+5", 
        desc: "核心為「熱號規律」。鎖定上期開出的號碼及其鄰近 5 位數關聯號，捕捉短期內重複出現的高頻率路徑。",
        logic: "頻率加權 60% + 關聯性 30% + 擾動 10%" 
    },
    { 
        name: "平衡型策略", type: "mix", pool: "last5+5+10", 
        desc: "掃描近 5 期數據。平衡中長期遺漏值與短期熱度，尋找正處於「上升趨勢」的號碼組合。",
        logic: "平均頻率 40% + 遺漏修正 40% + 隨機 20%" 
    },
    { 
        name: "激進型策略", type: "agg", pool: "last5+10", 
        desc: "採用大跨度相關性分析（+10 偏移）。旨在捕捉跳躍式或突變型的版路，適合尋求冷熱切換的轉折點。",
        logic: "關聯矩陣 50% + 跳號預測 30% + 隨機 20%" 
    }
];

document.getElementById('csvFile').addEventListener('change', function(e){
    const name = e.target.files[0] ? e.target.files[0].name : "點擊選取歷史數據 CSV";
    document.getElementById('fileLabel').innerText = name;
});

async function runAll(){
    const fileInput = document.getElementById("csvFile");
    if(!fileInput.files[0]){ alert("請先選取 CSV 檔案"); return; }
    const text = await fileInput.files[0].text();
    HIST_DATA = parseCSV(text);
    if(HIST_DATA.length < 20) { alert("數據量不足以進行回測"); return; }
    
    buildCorrelationMatrix(HIST_DATA);
    showHistory(HIST_DATA);
    
    // 執行回測並渲染表格
    const stats = doBacktest(HIST_DATA);
    renderStatsTable(stats);
    
    // 渲染圖表與推薦組合
    drawTrendChart(stats.map(s=>s.hit2), stats.map(s=>s.hit3));
    renderTopCombinations(HIST_DATA);
}

function parseCSV(text){
    const lines = text.trim().split("\n");
    lines.shift();
    return lines.map(l => {
        const p = l.split(",");
        if(p.length < 7) return null;
        return {date: p[0].trim(), nums: p.slice(2, 7).map(n => parseInt(n.trim())).sort((a,b)=>a-b)};
    }).filter(x => x !== null).sort((a,b) => new Date(a.date) - new Date(b.date));
}

function buildCorrelationMatrix(data) {
    CORR_MATRIX = {};
    for (let i = 0; i < data.length - 1; i++) {
        const current = data[i].nums;
        const next = data[i+1].nums;
        current.forEach(c => {
            if (!CORR_MATRIX[c]) CORR_MATRIX[c] = {};
            next.forEach(n => { CORR_MATRIX[c][n] = (CORR_MATRIX[c][n] || 0) + 1; });
        });
    }
}

function showHistory(data){
    let html = "<table>";
    data.slice(-5).reverse().forEach(d => {
        html += `<tr><td style='opacity:0.6; font-size:0.8rem;'>${d.date.slice(5)}</td><td>${d.nums.map(n => `<span class="ball">${String(n).padStart(2,'0')}</span>`).join("")}</td></tr>`;
    });
    html += "</table>";
    document.getElementById("history").innerHTML = "<h3>近期開獎歷史</h3>" + html;
}

// 補全：期望值計算 (基於近 60 期模擬)
function calculateExpectedValue(pick, testData) {
    let score = 0;
    testData.forEach(d => {
        const matches = d.nums.filter(n => pick.includes(n)).length;
        if(matches === 2) score += 1;
        if(matches === 3) score += 10;
        if(matches >= 4) score += 50;
    });
    return score / testData.length;
}

// 補全：智能選號邏輯
function generateSmartPick(prev, rule) {
    const pool = new Set();
    const lastNums = prev[prev.length - 1].nums;
    
    if(rule.pool.includes("last1")) lastNums.forEach(n => pool.add(n));
    if(rule.pool.includes("last5")) prev.slice(-5).forEach(d => d.nums.forEach(n => pool.add(n)));
    
    const poolArr = [...pool];
    poolArr.forEach(n => {
        if(rule.pool.includes("+5") && n+5 <= 39) pool.add(n+5);
        if(rule.pool.includes("+10") && n+10 <= 39) pool.add(n+10);
    });

    // 加入隨機性與回測優化
    let best = [], maxEV = -1;
    for(let i=0; i<50; i++) {
        const candidate = [...pool].sort(() => 0.5 - Math.random()).slice(0, 5).sort((a,b)=>a-b);
        const ev = calculateExpectedValue(candidate, prev.slice(-30));
        if(ev > maxEV) { maxEV = ev; best = candidate; }
    }
    return best;
}

// 補全：策略回測表現
function doBacktest(data) {
    return RULES.map(rule => {
        let hit2 = 0, hit3 = 0;
        const range = Math.min(60, data.length - 10);
        for(let i = data.length - range; i < data.length - 1; i++) {
            const pick = generateSmartPick(data.slice(0, i), rule);
            const matches = data[i+1].nums.filter(n => pick.includes(n)).length;
            if(matches === 2) hit2++;
            if(matches >= 3) hit3++;
        }
        return { name: rule.name, hit2, hit3, score: ((hit2 + hit3*10)/range).toFixed(2) };
    });
}

// 補全：表格渲染
function renderStatsTable(stats) {
    let html = "<table><thead><tr><th>策略</th><th>二星</th><th>三星+</th><th>綜合評分</th></tr></thead><tbody>";
    stats.forEach(s => {
        html += `<tr><td>${s.name}</td><td>${s.hit2}</td><td>${s.hit3}</td><td style="color:var(--gold)">${s.score}</td></tr>`;
    });
    html += "</tbody></table>";
    document.getElementById("stats_table").innerHTML = "<h3>策略回測表現</h3>" + html;
}

// 補全：推薦組合渲染
function renderTopCombinations(data) {
    const res = document.getElementById("results");
    res.innerHTML = "<h3>智能推荐組合 (點擊策略查看邏輯)</h3>";
    RULES.forEach(rule => {
        const pick = generateSmartPick(data, rule);
        const div = document.createElement("div");
        div.className = "strategy-block";
        div.onclick = function() {
            const detail = this.querySelector(".logic-detail");
            detail.style.display = detail.style.display === 'block' ? 'none' : 'block';
        };
        div.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <strong>${rule.name}</strong>
                <span class="rate-badge">量化決策已優化</span>
            </div>
            <div style="margin-top:15px;">
                ${pick.map(n => `<span class="ball" style="border:1px solid var(--accent)">${String(n).padStart(2,'0')}</span>`).join("")}
            </div>
            <div class="logic-detail">
                <p><strong>策略描述：</strong>${rule.desc}</p>
                <p><strong>核心邏輯：</strong>${rule.logic}</p>
            </div>
        `;
        res.appendChild(div);
    });
}

function drawTrendChart(data2, data3) {
    const ctx = document.getElementById('trendChart').getContext('2d');
    if(trendChartInstance) trendChartInstance.destroy();
    trendChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: RULES.map(r => r.name),
            datasets: [
                { label: '二星命中次數', data: data2, backgroundColor: 'rgba(56, 189, 248, 0.5)' },
                { label: '三星命中次數', data: data3, backgroundColor: 'rgba(251, 191, 36, 0.5)' }
            ]
        },
        options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
    });
}

function verifyUserPick() {
    const user = [1,2,3,4,5].map(i => parseInt(document.getElementById("userNum"+i).value)).filter(n=>!isNaN(n));
    if(user.length < 2) return alert("請至少輸入兩個號碼");
    let h2=0, h3=0, h4=0;
    HIST_DATA.forEach(d => {
        const m = d.nums.filter(n => user.includes(n)).length;
        if(m===2) h2++; else if(m===3) h3++; else if(m>=4) h4++;
    });
    document.getElementById("userPickResult").innerHTML = `
        <div style="text-align:center;">
            歷史二星：<span style="color:var(--accent)">${h2}</span> 次 | 
            三星：<span style="color:var(--gold)">${h3}</span> 次 | 
            四星以上：<span style="color:var(--success)">${h4}</span> 次
        </div>`;
}
</script>
