/**
 * v262 策略：相位攻擊(5) + 冷門防禦(3)
 */
function getV262Pick8(hist) {
    if(hist.length < 10) return {res:[], phaseNodes:[], balanceNodes:[]};
    const last = hist[hist.length-1].nums;
    
    let pool = [];
    for (let i=1; i<=39; i++) {
        let gap = 0;
        for(let k=hist.length-1; k>=0; k--) { if(!hist[k].nums.includes(i)) gap++; else break; }
        
        // 1. 相位權重：擴大至 +/- 2 鄰位
        let drift = 0;
        if (last.some(ln => Math.abs(ln-i) === 1)) drift = 45000;
        if (last.some(ln => Math.abs(ln-i) === 2)) drift = 20000; // 增加防禦跳號
        
        // 2. 遺漏加成：鎖定黃金噴發區與極端冷門區
        let gapSc = (gap >= 5 && gap <= 12) ? 35000 : 0;
        if (gap > 20) gapSc = 50000; // 強制拉高長期未開號的優先級
        
        let sc = drift + gapSc + (gap === 0 ? 10000 : 0);
        pool.push({n: i, sc, odd: i%2!==0, gap});
    }

    // 排序
    let sorted = pool.sort((a,b) => b.sc - a.sc);
    let res = [], phaseNodes = [], balanceNodes = [];

    // A. 抓取前 5 碼作為核心相位碼 (攻擊型)
    sorted.slice(0, 5).forEach(p => { 
        res.push(p.n); 
        phaseNodes.push(p.n); 
    });

    // B. 從遺漏值最高者中抓取 3 碼 (防禦型)
    let coldCandidates = pool
        .filter(p => !res.includes(p.n))
        .sort((a,b) => b.gap - a.gap);
    
    for(let i=0; i<3; i++) {
        if(coldCandidates[i]) {
            res.push(coldCandidates[i].n);
            balanceNodes.push(coldCandidates[i].n);
        }
    }

    return { res: res.sort((a,b)=>a-b), phaseNodes, balanceNodes };
}
